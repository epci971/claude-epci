# Ralph.sh Template

> Generated by `/decompose` command for autonomous execution

## Template

```bash
#!/bin/bash
# Ralph loop — generated by /decompose
# Run this script directly in terminal for context liberation between stories
#
# Usage:
#   ./ralph.sh              # Verbose output (default)
#   ./ralph.sh --quiet      # Minimal output
#   ./ralph.sh --dry-run    # Show stories without executing
#   ./ralph.sh --help       # Show help
#
# To stop: Ctrl+C
set -e

# Configuration
MAX_ITERATIONS=${MAX_ITERATIONS:-50}
PRD_FILE="./prd.json"
PROGRESS_FILE="./progress.txt"

# Verbose mode is ON by default
VERBOSE=${VERBOSE:-true}
DRY_RUN=false

# Lib directory (for response_analyzer, etc.)
LIB_DIR="${EPCI_LIB_DIR:-$(dirname "$0")/lib}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Help function
show_help() {
    cat << EOF
Ralph Wiggum — Autonomous Executor
Usage: ./ralph.sh [OPTIONS]
Options:
    -q, --quiet      Disable verbose output
    --dry-run        Show pending stories without executing
    -h, --help       Show this help
EOF
}

# Argument parsing
while [[ $# -gt 0 ]]; do
    case $1 in
        -q|--quiet) VERBOSE=false; shift ;;
        --dry-run) DRY_RUN=true; shift ;;
        -h|--help) show_help; exit 0 ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

# Source libs if available
[[ -f "$LIB_DIR/date_utils.sh" ]] && source "$LIB_DIR/date_utils.sh"
[[ -f "$LIB_DIR/response_analyzer.sh" ]] && source "$LIB_DIR/response_analyzer.sh" && HAS_ANALYZER=true || HAS_ANALYZER=false

# Progress bar
show_progress_bar() {
    local c=$1 t=$2 w=40
    [[ $t -eq 0 ]] && return
    local p=$((c * 100 / t)) f=$((c * w / t))
    printf "[%-${w}s] %d%% (%d/%d)\n" "$(printf '#%.0s' $(seq 1 $f))" "$p" "$c" "$t"
}

# Time tracking
START_TIME=$(date +%s)
get_elapsed() { local e=$(($(date +%s) - START_TIME)); printf "%02d:%02d:%02d" $((e/3600)) $((e%3600/60)) $((e%60)); }
STORY_START=0
start_story_timer() { STORY_START=$(date +%s); }
get_story_time() { local e=$(($(date +%s) - STORY_START)); printf "%02d:%02d" $((e/60)) $((e%60)); }

echo "========================================"
echo "  Ralph Wiggum — Autonomous Executor"
[[ "$VERBOSE" == "true" ]] && echo -e "         ${CYAN}[VERBOSE MODE]${NC}"
echo "========================================"
echo "PRD: $PRD_FILE"
echo "Max iterations: $MAX_ITERATIONS"
echo ""

# Validation
[[ ! -f "$PRD_FILE" ]] && echo -e "${RED}Error: PRD not found${NC}" && exit 1

# Dry run
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${CYAN}=== DRY RUN ===${NC}"
    jq -r '.userStories[] | select(.passes==false) | "  - \(.id) — \(.title)"' "$PRD_FILE"
    exit 0
fi

echo "[$(date -Iseconds)] Ralph started" >> "$PROGRESS_FILE"

for ((i=1; i<=MAX_ITERATIONS; i++)); do
    PENDING=$(jq '[.userStories[] | select(.passes==false and .status!="blocked")] | length' "$PRD_FILE")
    COMPLETED=$(jq '[.userStories[] | select(.passes==true)] | length' "$PRD_FILE")
    TOTAL=$(jq '.userStories | length' "$PRD_FILE")

    [[ "$PENDING" -eq 0 ]] && echo -e "${GREEN}All stories complete!${NC}" && exit 0

    NEXT_STORY=$(jq -r '[.userStories[] | select(.passes==false and .status!="blocked")][0].id' "$PRD_FILE")
    NEXT_TITLE=$(jq -r '[.userStories[] | select(.passes==false and .status!="blocked")][0].title' "$PRD_FILE")

    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "\n${BLUE}+--------------------------------------------------------------------+${NC}"
        echo -e "${BLUE}|        Story Execution — Iteration $i                              |${NC}"
        echo -e "${BLUE}+--------------------------------------------------------------------+${NC}"
        echo -e "${YELLOW}Story:${NC}   $NEXT_STORY"
        echo -e "${YELLOW}Title:${NC}   $NEXT_TITLE"
        echo -e "${YELLOW}Elapsed:${NC} $(get_elapsed)"
        show_progress_bar "$COMPLETED" "$TOTAL"
    else
        echo -e "\n${YELLOW}=== Iteration $i ===${NC}"
        echo "Progress: $COMPLETED/$TOTAL, Next: $NEXT_STORY"
    fi

    start_story_timer
    # Use tee to show output in real-time AND capture for analysis
    OUTPUT_FILE=$(mktemp)
    claude --dangerously-skip-permissions --verbose "/epci:ralph-exec --prd $PRD_FILE" 2>&1 | tee "$OUTPUT_FILE" || true
    OUTPUT=$(cat "$OUTPUT_FILE")

    # Verbose: analyze response
    if [[ "$VERBOSE" == "true" && "$HAS_ANALYZER" == "true" ]]; then
        analyze_response "$OUTPUT_FILE" "$i" ".analysis_$i" 2>/dev/null && log_analysis_summary ".analysis_$i" 2>/dev/null
        rm -f ".analysis_$i"
        echo -e "${YELLOW}Duration:${NC} $(get_story_time)"
    fi
    rm -f "$OUTPUT_FILE"

    # Check signals
    if echo "$OUTPUT" | grep -q '<promise>STORY_DONE</promise>'; then
        echo -e "${GREEN}Story $NEXT_STORY completed${NC}"
    elif echo "$OUTPUT" | grep -q '<promise>ALL_DONE</promise>'; then
        echo -e "${GREEN}All complete!${NC}"; exit 0
    else
        echo -e "${RED}Story $NEXT_STORY failed${NC}"
    fi

    sleep 2
done

echo -e "${RED}Max iterations reached${NC}"
exit 1
```

## Notes

- **LIB_DIR**: Uses `${EPCI_LIB_DIR:-$(dirname "$0")/lib}` for portability
- **Autonomous mode**: `--dangerously-skip-permissions` enables overnight execution
- Each `claude "/epci:ralph-exec"` call creates fresh context (memory liberation)
