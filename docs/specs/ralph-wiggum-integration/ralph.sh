#!/usr/bin/env bash
#
# Ralph Loop Script â€” Ralph Wiggum Integration
# Generated by EPCI /decompose v5.2
#
# Usage:
#   ./ralph.sh [--continue] [--max-iterations N] [--dry-run]
#
# This script executes user stories from prd.json in autonomous mode.
# Each story is processed through /brief -> /quick or /epci workflow.
#

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PRD_FILE="${SCRIPT_DIR}/prd.json"
PROMPT_FILE="${SCRIPT_DIR}/PROMPT.md"
PROGRESS_FILE="${SCRIPT_DIR}/progress.txt"
SESSION_FILE="${SCRIPT_DIR}/.ralph-session.json"

# Import library functions
LIB_DIR="${SCRIPT_DIR}/lib"
if [[ -d "$LIB_DIR" ]]; then
    source "${LIB_DIR}/circuit_breaker.sh" 2>/dev/null || true
    source "${LIB_DIR}/response_analyzer.sh" 2>/dev/null || true
    source "${LIB_DIR}/date_utils.sh" 2>/dev/null || true
fi

# Defaults
MAX_ITERATIONS="${MAX_ITERATIONS:-50}"
MAX_CALLS_PER_HOUR="${MAX_CALLS_PER_HOUR:-100}"
DRY_RUN=false
CONTINUE_SESSION=false

# ============================================================================
# Argument Parsing
# ============================================================================

while [[ $# -gt 0 ]]; do
    case $1 in
        --continue)
            CONTINUE_SESSION=true
            shift
            ;;
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --calls)
            MAX_CALLS_PER_HOUR="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# ============================================================================
# Validation
# ============================================================================

if [[ ! -f "$PRD_FILE" ]]; then
    echo "ERROR: prd.json not found at $PRD_FILE"
    echo "Run /decompose first to generate the project files."
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "ERROR: jq is required but not installed."
    echo "Install with: brew install jq (macOS) or apt install jq (Linux)"
    exit 1
fi

# ============================================================================
# Helper Functions
# ============================================================================

log() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $*" | tee -a "$PROGRESS_FILE"
}

get_pending_stories() {
    jq -r '.userStories[] | select(.passes == false) | .id' "$PRD_FILE"
}

get_story_by_id() {
    local story_id="$1"
    jq ".userStories[] | select(.id == \"$story_id\")" "$PRD_FILE"
}

mark_story_complete() {
    local story_id="$1"
    local temp_file
    temp_file=$(mktemp)

    jq "(.userStories[] | select(.id == \"$story_id\")) |= . + {passes: true, status: \"completed\"}" \
        "$PRD_FILE" > "$temp_file" && mv "$temp_file" "$PRD_FILE"

    log "Story $story_id marked as completed"
}

mark_story_failed() {
    local story_id="$1"
    local error_msg="$2"
    local temp_file
    temp_file=$(mktemp)

    jq "(.userStories[] | select(.id == \"$story_id\")).execution.last_error = \"$error_msg\" |
        (.userStories[] | select(.id == \"$story_id\")).execution.attempts += 1" \
        "$PRD_FILE" > "$temp_file" && mv "$temp_file" "$PRD_FILE"

    log "Story $story_id marked as failed: $error_msg"
}

count_completed() {
    jq '[.userStories[] | select(.passes == true)] | length' "$PRD_FILE"
}

count_total() {
    jq '.userStories | length' "$PRD_FILE"
}

# ============================================================================
# Session Management
# ============================================================================

init_session() {
    if [[ "$CONTINUE_SESSION" == true ]] && [[ -f "$SESSION_FILE" ]]; then
        log "Resuming session from $SESSION_FILE"
        return 0
    fi

    cat > "$SESSION_FILE" << EOF
{
    "started_at": "$(date -Iseconds)",
    "iteration": 0,
    "max_iterations": $MAX_ITERATIONS,
    "stories_completed": 0,
    "stories_failed": 0
}
EOF
    log "New session initialized"
}

update_session() {
    local iteration="$1"
    local completed="$2"
    local failed="$3"
    local temp_file
    temp_file=$(mktemp)

    jq ".iteration = $iteration | .stories_completed = $completed | .stories_failed = $failed" \
        "$SESSION_FILE" > "$temp_file" && mv "$temp_file" "$SESSION_FILE"
}

get_iteration() {
    jq -r '.iteration' "$SESSION_FILE"
}

# ============================================================================
# Main Loop
# ============================================================================

main() {
    log "=== Ralph Loop Starting ==="
    log "PRD: $PRD_FILE"
    log "Max iterations: $MAX_ITERATIONS"

    # Initialize session
    init_session

    local iteration
    iteration=$(get_iteration)
    local completed_count
    local failed_count=0

    # Dry run mode
    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        echo "=== DRY RUN MODE ==="
        echo "Would execute the following stories:"
        echo ""
        get_pending_stories | while read -r story_id; do
            local title
            title=$(jq -r ".userStories[] | select(.id == \"$story_id\") | .title" "$PRD_FILE")
            echo "  - $story_id: $title"
        done
        echo ""
        echo "Total pending: $(jq '[.userStories[] | select(.passes == false)] | length' "$PRD_FILE")"
        echo "Total completed: $(count_completed)"
        exit 0
    fi

    # Main execution loop
    while true; do
        iteration=$((iteration + 1))
        completed_count=$(count_completed)

        log "--- Iteration $iteration / $MAX_ITERATIONS ---"
        log "Progress: $completed_count / $(count_total) stories completed"

        # Check iteration limit
        if [[ $iteration -gt $MAX_ITERATIONS ]]; then
            log "Max iterations reached. Stopping."
            break
        fi

        # Get next pending story
        local next_story
        next_story=$(get_pending_stories | head -1)

        if [[ -z "$next_story" ]]; then
            log "All stories completed!"
            break
        fi

        log "Processing story: $next_story"

        # Get story details
        local story_json
        story_json=$(get_story_by_id "$next_story")
        local story_title
        story_title=$(echo "$story_json" | jq -r '.title')
        local parent_spec
        parent_spec=$(echo "$story_json" | jq -r '.context.parent_spec')

        log "Title: $story_title"
        log "Parent spec: $parent_spec"

        # Execute story via Claude
        # This is where the actual Claude invocation would happen
        # For now, we simulate the execution

        log "Invoking Claude for story execution..."

        # TODO: Replace with actual Claude invocation
        # claude --print -p "$PROMPT_FILE" --context "Execute story $next_story: $story_title"

        # Simulate success for demo
        # In production, this would check the actual Claude response
        local success=true

        if [[ "$success" == true ]]; then
            mark_story_complete "$next_story"
            git add -A && git commit -m "feat: Complete $next_story - $story_title" || true
        else
            failed_count=$((failed_count + 1))
            mark_story_failed "$next_story" "Execution failed"

            # Circuit breaker check
            if [[ $failed_count -ge 3 ]]; then
                log "WARNING: Multiple consecutive failures detected"
                # Check circuit breaker state if available
                if type cb_check &>/dev/null; then
                    if ! cb_check; then
                        log "Circuit breaker OPEN. Stopping execution."
                        break
                    fi
                fi
            fi
        fi

        # Update session
        update_session "$iteration" "$(count_completed)" "$failed_count"

        # Brief pause between iterations
        sleep 2
    done

    # Final summary
    log "=== Ralph Loop Complete ==="
    log "Total iterations: $iteration"
    log "Stories completed: $(count_completed) / $(count_total)"
    log "Stories failed: $failed_count"

    # Cleanup session file on successful completion
    if [[ $(count_completed) -eq $(count_total) ]]; then
        rm -f "$SESSION_FILE"
        log "Session file cleaned up (all stories complete)"
    fi
}

# ============================================================================
# Entry Point
# ============================================================================

main "$@"
